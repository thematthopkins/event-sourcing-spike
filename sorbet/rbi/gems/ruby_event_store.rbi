# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ruby_event_store/all/ruby_event_store.rbi
#
# ruby_event_store-2.2.0

module RubyEventStore
end
class RubyEventStore::Dispatcher
  def call(subscriber, event, _); end
  def verify(subscriber); end
end
class RubyEventStore::Subscriptions
  def add_global_subscription(subscriber); end
  def add_subscription(subscriber, event_types); end
  def add_thread_global_subscription(subscriber); end
  def add_thread_subscription(subscriber, event_types); end
  def all_for(event_type); end
  def default_event_type_resolver; end
  def event_type_resolver; end
  def global; end
  def initialize(event_type_resolver: nil); end
  def local; end
  def resolve_event_type(type); end
  def resolve_event_types(event_types); end
  def thread; end
end
class RubyEventStore::Subscriptions::ThreadSubscriptions
  def all_for(event_type); end
  def global; end
  def initialize; end
  def local; end
end
class RubyEventStore::Subscriptions::LocalSubscriptions
  def add(subscription, event_types); end
  def all_for(event_type); end
  def initialize; end
end
class RubyEventStore::Subscriptions::GlobalSubscriptions
  def add(subscription); end
  def all_for(_event_type); end
  def initialize; end
end
class RubyEventStore::Subscriptions::ThreadLocalSubscriptions
  def add(subscription, event_types); end
  def all_for(event_type); end
  def initialize; end
end
class RubyEventStore::Subscriptions::ThreadGlobalSubscriptions
  def add(subscription); end
  def all_for(_event_type); end
  def initialize; end
end
class RubyEventStore::Broker
  def add_global_subscription(subscriber); end
  def add_subscription(subscriber, event_types); end
  def add_thread_global_subscription(subscriber); end
  def add_thread_subscription(subscriber, event_types); end
  def call(event, record); end
  def dispatcher; end
  def initialize(subscriptions:, dispatcher:); end
  def subscriptions; end
  def verify_subscription(subscriber); end
end
class RubyEventStore::InMemoryRepository
  def append_to_stream(records, stream, expected_version); end
  def count(spec); end
  def delete_stream(stream); end
  def event_ids_of_stream(stream); end
  def has_event?(event_id); end
  def has_event_in_stream?(event_id, stream_name); end
  def index_of(source, event_id); end
  def initialize(serializer: nil); end
  def last_stream_event(stream); end
  def last_stream_version(stream); end
  def link_to_stream(event_ids, stream, expected_version); end
  def mutex; end
  def ordered(serialized_records, spec); end
  def read(spec); end
  def read_event(event_id); end
  def read_scope(spec); end
  def serialized_records_of_stream(stream); end
  def serializer; end
  def storage; end
  def streams; end
  def streams_of(event_id); end
  def update_messages(records); end
  def with_synchronize(expected_version, stream, &block); end
end
class RubyEventStore::Projection
  def call(event); end
  def current_state; end
  def handled_events; end
  def handlers; end
  def init(handler); end
  def initial_state; end
  def initialize(streams: nil); end
  def read_scope(event_store, stream, count, start); end
  def reduce_from_all_streams(event_store, start, count); end
  def reduce_from_streams(event_store, start, count); end
  def run(event_store, start: nil, count: nil); end
  def self.from_all_streams; end
  def self.from_stream(stream_or_streams); end
  def self.new(*arg0); end
  def start_events(start); end
  def streams; end
  def transition(state, event); end
  def valid_starting_point?(start); end
  def when(events, handler); end
end
class RubyEventStore::Error < StandardError
end
class RubyEventStore::WrongExpectedEventVersion < RubyEventStore::Error
end
class RubyEventStore::InvalidExpectedVersion < RubyEventStore::Error
end
class RubyEventStore::IncorrectStreamData < RubyEventStore::Error
end
class RubyEventStore::SubscriberNotExist < RubyEventStore::Error
end
class RubyEventStore::InvalidPageStart < RubyEventStore::Error
end
class RubyEventStore::InvalidPageStop < RubyEventStore::Error
end
class RubyEventStore::InvalidPageSize < RubyEventStore::Error
end
class RubyEventStore::EventDuplicatedInStream < RubyEventStore::Error
end
class RubyEventStore::ReservedInternalName < RubyEventStore::Error
end
class RubyEventStore::InvalidHandler < RubyEventStore::Error
end
class RubyEventStore::EventNotFound < RubyEventStore::Error
  def event_id; end
  def initialize(event_id); end
end
class RubyEventStore::Client
  def append(events, stream_name: nil, expected_version: nil); end
  def append_records_to_stream(records, stream_name:, expected_version:); end
  def broker; end
  def clock; end
  def correlation_id_generator; end
  def default_clock; end
  def default_correlation_id_generator; end
  def delete_stream(stream_name); end
  def deserialize(serializer:, event_type:, event_id:, data:, metadata:, timestamp: nil, valid_at: nil); end
  def enrich_event_metadata(event); end
  def enrich_events_metadata(events); end
  def event_type_resolver; end
  def initialize(repository:, mapper: nil, subscriptions: nil, dispatcher: nil, clock: nil, correlation_id_generator: nil); end
  def inspect; end
  def link(event_ids, stream_name:, expected_version: nil); end
  def mapper; end
  def metadata; end
  def metadata=(value); end
  def overwrite(events_or_event); end
  def publish(events, stream_name: nil, expected_version: nil); end
  def read; end
  def repository; end
  def streams_of(event_id); end
  def subscribe(subscriber = nil, to:, &proc); end
  def subscribe_to_all_events(subscriber = nil, &proc); end
  def subscribers_for(event_class); end
  def subscriptions; end
  def transform(events); end
  def with_metadata(metadata, &block); end
  def within(&block); end
end
class RubyEventStore::Client::Within
  def add_thread_global_subscribers; end
  def add_thread_subscribers; end
  def call; end
  def initialize(block, broker); end
  def subscribe(handler = nil, to:, &handler2); end
  def subscribe_to_all_events(*handlers, &handler2); end
end
class RubyEventStore::Metadata
  def <(*args, &block); end
  def <=(*args, &block); end
  def >(*args, &block); end
  def >=(*args, &block); end
  def [](key); end
  def []=(key, val); end
  def allowed_types; end
  def assoc(*args, &block); end
  def clear(*args, &block); end
  def compact!(*args, &block); end
  def compact(*args, &block); end
  def delete(*args, &block); end
  def delete_if(*args, &block); end
  def dig(*args, &block); end
  def each(&block); end
  def each_key(*args, &block); end
  def each_pair(*args, &block); end
  def each_value(*args, &block); end
  def empty?(*args, &block); end
  def fetch(*args, &block); end
  def fetch_values(*args, &block); end
  def flatten(*args, &block); end
  def has_key?(*args, &block); end
  def has_value?(*args, &block); end
  def initialize(h = nil); end
  def keep_if(*args, &block); end
  def key(*args, &block); end
  def key?(*args, &block); end
  def keys(*args, &block); end
  def length(*args, &block); end
  def rassoc(*args, &block); end
  def reject!(*args, &block); end
  def select!(*args, &block); end
  def shift(*args, &block); end
  def size(*args, &block); end
  def slice(*args, &block); end
  def to_proc(*args, &block); end
  def transform_keys(*args, &block); end
  def transform_values(*args, &block); end
  def value?(*args, &block); end
  def values(*args, &block); end
  def values_at(*args, &block); end
  extend Forwardable
  include Enumerable
end
class RubyEventStore::Specification
  def as_at; end
  def as_of; end
  def backward; end
  def between(time_range); end
  def count; end
  def each; end
  def each_batch; end
  def event!(event_id); end
  def event(event_id); end
  def events(event_ids); end
  def first; end
  def forward; end
  def from(start); end
  def in_batches(batch_size = nil); end
  def in_batches_of(batch_size = nil); end
  def initialize(reader, result = nil); end
  def last; end
  def limit(count); end
  def map(&block); end
  def newer_than(time); end
  def newer_than_or_equal(time); end
  def of_type(*types); end
  def of_types(*types); end
  def older_than(time); end
  def older_than_or_equal(time); end
  def read_first; end
  def read_last; end
  def reader; end
  def reduce(accumulator = nil, &block); end
  def result; end
  def stream(stream_name); end
  def to(stop); end
  def to_a; end
  def with_id(event_ids); end
end
class RubyEventStore::SpecificationResult
  def ==(other_spec); end
  def all?; end
  def attributes; end
  def backward?; end
  def batch_size; end
  def batched?; end
  def dup; end
  def first?; end
  def forward?; end
  def get_direction; end
  def hash; end
  def initialize(direction: nil, start: nil, stop: nil, older_than: nil, older_than_or_equal: nil, newer_than: nil, newer_than_or_equal: nil, time_sort_by: nil, count: nil, stream: nil, read_as: nil, batch_size: nil, with_ids: nil, with_types: nil); end
  def last?; end
  def limit; end
  def limit?; end
  def newer_than; end
  def newer_than_or_equal; end
  def older_than; end
  def older_than_or_equal; end
  def start; end
  def stop; end
  def stream; end
  def time_sort_by; end
  def with_ids; end
  def with_ids?; end
  def with_types; end
  def with_types?; end
end
class RubyEventStore::SpecificationReader
  def count(specification_result); end
  def each(specification_result); end
  def has_event?(event_id); end
  def initialize(repository, mapper); end
  def mapper; end
  def one(specification_result); end
  def repository; end
end
class RubyEventStore::Event
  def ==(other_event); end
  def causation_id; end
  def causation_id=(val); end
  def correlate_with(other_message); end
  def correlation_id; end
  def correlation_id=(val); end
  def data; end
  def eql?(other_event); end
  def event_id; end
  def event_type; end
  def hash; end
  def initialize(event_id: nil, metadata: nil, data: nil); end
  def message_id; end
  def metadata; end
  def timestamp; end
  def valid_at; end
end
class RubyEventStore::Stream
  def ==(other_stream); end
  def eql?(other_stream); end
  def global?; end
  def hash; end
  def initialize(name); end
  def name; end
end
class RubyEventStore::ExpectedVersion
  def ==(other_expected_version); end
  def any?; end
  def auto?; end
  def eql?(other_expected_version); end
  def hash; end
  def initialize(version); end
  def invalid_version!; end
  def none?; end
  def resolve_for(stream, resolver = nil); end
  def self.any; end
  def self.auto; end
  def self.none; end
  def version; end
end
class RubyEventStore::Record
  def ==(other); end
  def data; end
  def eql?(other); end
  def event_id; end
  def event_type; end
  def hash; end
  def initialize(event_id:, data:, metadata:, event_type:, timestamp:, valid_at:); end
  def metadata; end
  def serialize(serializer); end
  def timestamp; end
  def to_h; end
  def valid_at; end
end
class RubyEventStore::Record::StringsRequired < StandardError
end
class RubyEventStore::SerializedRecord
  def ==(other); end
  def data; end
  def deserialize(serializer); end
  def eql?(other); end
  def event_id; end
  def event_type; end
  def hash; end
  def initialize(event_id:, data:, metadata:, event_type:, timestamp:, valid_at:); end
  def metadata; end
  def timestamp; end
  def to_h; end
  def valid_at; end
end
class RubyEventStore::SerializedRecord::StringsRequired < StandardError
end
module RubyEventStore::NULL
  def self.dump(value); end
  def self.load(value); end
end
class RubyEventStore::TransformKeys
  def self.deep_transform(data, &block); end
  def self.stringify(data); end
  def self.symbolize(data); end
end
module RubyEventStore::Mappers
end
class RubyEventStore::Mappers::EncryptionKey
  def cipher; end
  def ciphertext_from_authenticated(crypto, message); end
  def decrypt(message, iv); end
  def encrypt(message, iv); end
  def encrypt_authenticated(crypto, message); end
  def initialize(cipher:, key:); end
  def key; end
  def prepare_auth_data(crypto); end
  def prepare_decrypt(cipher); end
  def prepare_encrypt(cipher); end
  def random_iv; end
end
class RubyEventStore::Mappers::InMemoryEncryptionKeyRepository
  def create(identifier, cipher: nil); end
  def forget(identifier); end
  def initialize; end
  def key_of(identifier, cipher: nil); end
  def prepare_encrypt(cipher); end
end
module RubyEventStore::Mappers::Transformation
end
class RubyEventStore::Mappers::Transformation::DomainEvent
  def dump(domain_event); end
  def load(record); end
end
class RubyEventStore::Mappers::Transformation::Encryption
  def decrypt_attribute(data, attribute, meta); end
  def decrypt_data(data, meta); end
  def deep_dup(hash); end
  def dump(record); end
  def encrypt_attribute(data, attribute, meta); end
  def encrypt_data(data, meta); end
  def encryption_metadata(data, schema); end
  def encryption_schema(event_class); end
  def forgotten_data; end
  def initialize(key_repository, serializer: nil, forgotten_data: nil); end
  def key_repository; end
  def load(record); end
  def serializer; end
end
class RubyEventStore::Mappers::Transformation::Encryption::Leaf
  def self.===(hash); end
end
class RubyEventStore::Mappers::Transformation::Encryption::MissingEncryptionKey < StandardError
  def initialize(key_identifier); end
end
class RubyEventStore::Mappers::Transformation::EventClassRemapper
  def class_map; end
  def dump(record); end
  def initialize(class_map); end
  def load(record); end
end
class RubyEventStore::Mappers::Transformation::Upcast
  def dump(record); end
  def initialize(upcast_map); end
  def load(record); end
end
class RubyEventStore::Mappers::Transformation::Upcast::RecordUpcaster
  def call(record); end
  def initialize(upcast_map); end
end
class RubyEventStore::Mappers::Transformation::StringifyMetadataKeys
  def dump(record); end
  def load(record); end
  def stringify(record); end
end
class RubyEventStore::Mappers::Transformation::SymbolizeMetadataKeys
  def dump(record); end
  def load(record); end
  def symbolize(record); end
end
class RubyEventStore::Mappers::Pipeline
  def dump(domain_event); end
  def initialize(*transformations, to_domain_event: nil); end
  def load(record); end
  def transformations; end
end
class RubyEventStore::Mappers::PipelineMapper
  def event_to_record(domain_event); end
  def initialize(pipeline); end
  def pipeline; end
  def record_to_event(record); end
end
class RubyEventStore::Mappers::Default < RubyEventStore::Mappers::PipelineMapper
  def initialize(events_class_remapping: nil); end
end
class RubyEventStore::Mappers::ForgottenData
  def ==(other); end
  def eql?(other); end
  def initialize(string = nil); end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def to_s; end
end
class RubyEventStore::Mappers::EncryptionMapper < RubyEventStore::Mappers::PipelineMapper
  def initialize(key_repository, serializer: nil, forgotten_data: nil); end
end
class RubyEventStore::Mappers::InstrumentedMapper
  def event_to_record(domain_event); end
  def initialize(mapper, instrumentation); end
  def instrumentation; end
  def mapper; end
  def record_to_event(record); end
end
class RubyEventStore::Mappers::JSONMapper < RubyEventStore::Mappers::Default
  def initialize(events_class_remapping: nil); end
end
class RubyEventStore::Mappers::NullMapper < RubyEventStore::Mappers::PipelineMapper
  def initialize; end
end
class RubyEventStore::BatchEnumerator
  def batch_size; end
  def each; end
  def first; end
  def initialize(batch_size, total_limit, reader); end
  def reader; end
  def to_a; end
  def total_limit; end
end
class RubyEventStore::CorrelatedCommands
  def call(command); end
  def command_bus; end
  def event_store; end
  def initialize(event_store, command_bus); end
end
class Anonymous_Struct_40 < Struct
  def correlation_id; end
  def correlation_id=(_); end
  def message_id; end
  def message_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class RubyEventStore::CorrelatedCommands::MiniEvent < Anonymous_Struct_40
end
class RubyEventStore::LinkByMetadata
  def call(event); end
  def initialize(event_store:, key:, prefix: nil); end
end
class RubyEventStore::LinkByCorrelationId < RubyEventStore::LinkByMetadata
  def initialize(event_store:, prefix: nil); end
end
class RubyEventStore::LinkByCausationId < RubyEventStore::LinkByMetadata
  def initialize(event_store:, prefix: nil); end
end
class RubyEventStore::LinkByEventType
  def call(event); end
  def initialize(event_store:, prefix: nil); end
end
class RubyEventStore::ImmediateAsyncDispatcher
  def call(subscriber, _, record); end
  def initialize(scheduler:); end
  def verify(subscriber); end
end
class RubyEventStore::ComposedDispatcher
  def call(subscriber, event, record); end
  def initialize(*dispatchers); end
  def verify(subscriber); end
end
class RubyEventStore::InstrumentedRepository
  def append_to_stream(records, stream, expected_version); end
  def count(specification); end
  def delete_stream(stream); end
  def has_event?(event_id); end
  def initialize(repository, instrumentation); end
  def instrumentation; end
  def last_stream_event(stream); end
  def link_to_stream(event_ids, stream, expected_version); end
  def read(specification); end
  def repository; end
  def streams_of(event_id); end
  def update_messages(messages); end
end
class RubyEventStore::InstrumentedDispatcher
  def call(subscriber, event, record); end
  def dispatcher; end
  def initialize(dispatcher, instrumentation); end
  def instrumentation; end
  def verify(subscriber); end
end
